{"$message_type":"diagnostic","message":"file not found for module `types`","code":{"code":"E0583","explanation":"A file wasn't found for an out-of-line module.\n\nErroneous code example:\n\n```compile_fail,E0583\nmod file_that_doesnt_exist; // error: file not found for module\n\nfn main() {}\n```\n\nPlease be sure that a file corresponding to the module exists. If you\nwant to use a module named `file_that_doesnt_exist`, you need to have a file\nnamed `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\nsame directory.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":10,"line_start":1,"line_end":1,"column_start":1,"column_end":11,"is_primary":true,"text":[{"text":"mod types;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to create the module `types`, create file \"lore_ir\\src\\types.rs\" or \"lore_ir\\src\\types\\mod.rs\"","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if there is a `mod types` elsewhere in the crate already, import it with `use crate::...` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0583]\u001b[0m\u001b[1m\u001b[97m: file not found for module `types`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\lib.rs:1:1\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m mod types;\n  \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: to create the module `types`, create file \"lore_ir\\src\\types.rs\" or \"lore_ir\\src\\types\\mod.rs\"\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: if there is a `mod types` elsewhere in the crate already, import it with `use crate::...` instead\n\n"}
{"$message_type":"diagnostic","message":"unused import: `write`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"lore_ir\\src\\content_types\\display\\atom.rs","byte_start":15,"byte_end":20,"line_start":1,"line_end":1,"column_start":16,"column_end":21,"is_primary":true,"text":[{"text":"use std::fmt::{write, Display, Formatter};","highlight_start":16,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\display\\atom.rs","byte_start":15,"byte_end":22,"line_start":1,"line_end":1,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"use std::fmt::{write, Display, Formatter};","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `write`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\display\\atom.rs:1:16\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use std::fmt::{write, Display, Formatter};\n  \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[93m^^^^^\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\structure\\data\\line.rs","byte_start":125,"byte_end":140,"line_start":5,"line_end":5,"column_start":29,"column_end":44,"is_primary":true,"text":[{"text":"    pub content: Option<Box<dyn Content<'f>>>,","highlight_start":29,"highlight_end":44}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\structure\\data\\line.rs:5:29\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub content: Option<Box<dyn Content<'f>>>,\n  \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\n"}
{"$message_type":"diagnostic","message":"method not compatible with trait","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\atom.rs","byte_start":179,"byte_end":195,"line_start":5,"line_end":5,"column_start":28,"column_end":44,"is_primary":true,"text":[{"text":"    fn check(&'lc self) -> AtomContent<'lc> {","highlight_start":28,"highlight_end":44}],"label":"lifetime mismatch","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected signature `fn(&AtomContent<'_>) -> AtomContent<'_>`\n   found signature `fn(&'lc AtomContent<'_>) -> AtomContent<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the anonymous lifetime defined here...","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":92,"byte_end":97,"line_start":7,"line_end":7,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":14,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"...does not necessarily outlive the lifetime `'lc` as defined here","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\atom.rs","byte_start":107,"byte_end":110,"line_start":4,"line_end":4,"column_start":6,"column_end":9,"is_primary":true,"text":[{"text":"impl<'lc, 'f> Content<'f> for AtomContent<'lc> {","highlight_start":6,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: method not compatible with trait\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\atom.rs:5:28\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&'lc self) -> AtomContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mlifetime mismatch\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected signature `fn(\u001b[1m\u001b[35m&\u001b[0mAtomContent<'_>) -> AtomContent<'_>`\n             found signature `fn(\u001b[1m\u001b[35m&'lc \u001b[0mAtomContent<'_>) -> AtomContent<'_>`\n\u001b[1m\u001b[92mnote\u001b[0m: the anonymous lifetime defined here...\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:14\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[92m^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: ...does not necessarily outlive the lifetime `'lc` as defined here\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\atom.rs:4:6\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl<'lc, 'f> Content<'f> for AtomContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m      \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `as_content::Content::check::{anon_assoc#0}`","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":107,"byte_end":119,"line_start":7,"line_end":7,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":29,"highlight_end":41}],"label":"required by this bound in `Content::check::{anon_assoc#0}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `as_content::Content::check::{anon_assoc#0}`\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:29\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Content::check::{anon_assoc#0}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `(dyn as_content::Content<'f> + 'static)` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `(dyn as_content::Content<'f> + 'static)`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `as_content::Content::check::{anon_assoc#0}`","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"required by this bound in `Content::check::{anon_assoc#0}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the size for values of type `(dyn as_content::Content<'f> + 'static)` cannot be known at compilation time\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mdoesn't have a size known at compile-time\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `Sized` is not implemented for `(dyn as_content::Content<'f> + 'static)`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `as_content::Content::check::{anon_assoc#0}`\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Content::check::{anon_assoc#0}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `!: as_content::Content<'f>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\reference.rs","byte_start":221,"byte_end":237,"line_start":6,"line_end":6,"column_start":24,"column_end":40,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'f> {","highlight_start":24,"highlight_end":40}],"label":"the trait `as_content::Content<'f>` is not implemented for `!`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\reference.rs","byte_start":221,"byte_end":237,"line_start":6,"line_end":6,"column_start":24,"column_end":40,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'f> {","highlight_start":24,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":29850,"byte_end":29897,"line_start":879,"line_end":879,"column_start":9,"column_end":56,"is_primary":false,"text":[{"text":"        $crate::panicking::panic(\"not yet implemented\")","highlight_start":9,"highlight_end":56}],"label":"return type was inferred to be `!` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\reference.rs","byte_start":249,"byte_end":256,"line_start":7,"line_end":7,"column_start":9,"column_end":16,"is_primary":false,"text":[{"text":"        todo!()","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"todo!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":29810,"byte_end":29827,"line_start":877,"line_end":877,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"macro_rules! todo {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `as_content::Content<'lc>`","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\atom.rs","byte_start":102,"byte_end":148,"line_start":4,"line_end":4,"column_start":1,"column_end":47,"is_primary":true,"text":[{"text":"impl<'lc, 'f> Content<'f> for AtomContent<'lc> {","highlight_start":1,"highlight_end":47}],"label":"`AtomContent<'lc>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":134,"byte_end":182,"line_start":5,"line_end":5,"column_start":1,"column_end":49,"is_primary":true,"text":[{"text":"impl<'lc, 'f> Content<'f> for DomainContent<'lc> {","highlight_start":1,"highlight_end":49}],"label":"`DomainContent<'lc>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":128,"byte_end":174,"line_start":5,"line_end":5,"column_start":1,"column_end":47,"is_primary":true,"text":[{"text":"impl<'lc, 'f> Content<'f> for LinkContent<'lc> {","highlight_start":1,"highlight_end":47}],"label":"`LinkContent<'lc>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\reference.rs","byte_start":143,"byte_end":194,"line_start":5,"line_end":5,"column_start":1,"column_end":52,"is_primary":true,"text":[{"text":"impl<'lc, 'f> Content<'f> for ReferenceContent<'lc> {","highlight_start":1,"highlight_end":52}],"label":"`ReferenceContent<'lc>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `!: as_content::Content<'f>` is not satisfied\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\reference.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `as_content::Content<'f>` is not implemented for `!`\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         todo!()\n  \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mreturn type was inferred to be `!` here\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the following other types implement trait `as_content::Content<'lc>`\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\atom.rs:4:1\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m4\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl<'lc, 'f> Content<'f> for AtomContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`AtomContent<'lc>`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m::: \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:5:1\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl<'lc, 'f> Content<'f> for DomainContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`DomainContent<'lc>`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m::: \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:5:1\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl<'lc, 'f> Content<'f> for LinkContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`LinkContent<'lc>`\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m::: \u001b[0mlore_ir\\src\\content_types\\as_content\\reference.rs:5:1\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m impl<'lc, 'f> Content<'f> for ReferenceContent<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`ReferenceContent<'lc>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `as_content::Content::check::{anon_assoc#0}`","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":107,"byte_end":119,"line_start":7,"line_end":7,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":29,"highlight_end":41}],"label":"required by this bound in `Content::check::{anon_assoc#0}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `as_content::Content::check::{anon_assoc#0}`\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:29\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Content::check::{anon_assoc#0}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `(dyn as_content::Content<'f> + 'static)` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `(dyn as_content::Content<'f> + 'static)`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `as_content::Content::check::{anon_assoc#0}`","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"required by this bound in `Content::check::{anon_assoc#0}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the size for values of type `(dyn as_content::Content<'f> + 'static)` cannot be known at compilation time\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mdoesn't have a size known at compile-time\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `Sized` is not implemented for `(dyn as_content::Content<'f> + 'static)`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `as_content::Content::check::{anon_assoc#0}`\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Content::check::{anon_assoc#0}`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"you might have meant to use `Self` to refer to the implementing type","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":null,"suggested_replacement":"Self","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\u001b[1m\u001b[96mhelp\u001b[0m: you might have meant to use `Self` to refer to the implementing type\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[91m- \u001b[0m    fn check(&self) -> \u001b[91mdyn Content<'f>\u001b[0m {\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m+ \u001b[0m    fn check(&self) -> \u001b[92mSelf\u001b[0m {\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"return type cannot be a trait object without pointer indirection","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":216,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider returning an `impl Trait` instead of a `dyn Trait`","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":205,"line_start":6,"line_end":6,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":28}],"label":null,"suggested_replacement":"impl ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"alternatively, box the return type, and wrap all of the returned values in `Box::new`","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":201,"byte_end":201,"line_start":6,"line_end":6,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":216,"byte_end":216,"line_start":6,"line_end":6,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":">","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":228,"byte_end":228,"line_start":7,"line_end":7,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        todo!()","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\link.rs","byte_start":235,"byte_end":235,"line_start":7,"line_end":7,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"        todo!()","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0746]\u001b[0m\u001b[1m\u001b[97m: return type cannot be a trait object without pointer indirection\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\link.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mdoesn't have a size known at compile-time\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider returning an `impl Trait` instead of a `dyn Trait`\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[91m- \u001b[0m    fn check(&self) -> \u001b[91mdyn \u001b[0mContent<'f> {\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m+ \u001b[0m    fn check(&self) -> \u001b[92mimpl \u001b[0mContent<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: alternatively, box the return type, and wrap all of the returned values in `Box::new`\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m~ \u001b[0m    fn check(&self) -> \u001b[92mBox<\u001b[0mdyn Content<'f>\u001b[92m>\u001b[0m {\n\u001b[1m\u001b[96m7\u001b[0m \u001b[92m~ \u001b[0m        \u001b[92mBox::new(\u001b[0mtodo!()\u001b[92m)\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"you might have meant to use `Self` to refer to the implementing type","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":null,"suggested_replacement":"Self","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\u001b[1m\u001b[96mhelp\u001b[0m: you might have meant to use `Self` to refer to the implementing type\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[91m- \u001b[0m    fn check(&self) -> \u001b[91mdyn Content<'f>\u001b[0m {\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m+ \u001b[0m    fn check(&self) -> \u001b[92mSelf\u001b[0m {\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"return type cannot be a trait object without pointer indirection","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":224,"line_start":6,"line_end":6,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":39}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider returning an `impl Trait` instead of a `dyn Trait`","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":213,"line_start":6,"line_end":6,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":28}],"label":null,"suggested_replacement":"impl ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"alternatively, box the return type, and wrap all of the returned values in `Box::new`","code":null,"level":"help","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":209,"byte_end":209,"line_start":6,"line_end":6,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":224,"byte_end":224,"line_start":6,"line_end":6,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"    fn check(&self) -> dyn Content<'f> {","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":">","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":236,"byte_end":236,"line_start":7,"line_end":7,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        todo!()","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\domain.rs","byte_start":243,"byte_end":243,"line_start":7,"line_end":7,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"        todo!()","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0746]\u001b[0m\u001b[1m\u001b[97m: return type cannot be a trait object without pointer indirection\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\domain.rs:6:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> dyn Content<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mdoesn't have a size known at compile-time\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider returning an `impl Trait` instead of a `dyn Trait`\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[91m- \u001b[0m    fn check(&self) -> \u001b[91mdyn \u001b[0mContent<'f> {\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m+ \u001b[0m    fn check(&self) -> \u001b[92mimpl \u001b[0mContent<'f> {\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: alternatively, box the return type, and wrap all of the returned values in `Box::new`\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[92m~ \u001b[0m    fn check(&self) -> \u001b[92mBox<\u001b[0mdyn Content<'f>\u001b[92m>\u001b[0m {\n\u001b[1m\u001b[96m7\u001b[0m \u001b[92m~ \u001b[0m        \u001b[92mBox::new(\u001b[0mtodo!()\u001b[92m)\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\structure\\parser\\line.rs","byte_start":426,"byte_end":433,"line_start":16,"line_end":16,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        content,","highlight_start":9,"highlight_end":16}],"label":"expected `Option<Box<dyn Content<'_>>>`, found `Content<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Option<Box<(dyn as_content::Content<'_> + 'static)>>`\n   found enum `structure::data::content::Content<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\structure\\parser\\line.rs:16:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         content,\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Box<dyn Content<'_>>>`, found `Content<'_>`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected enum `\u001b[1m\u001b[35mOption<Box<(dyn as_content::Content<'_> + 'static)>>\u001b[0m`\n              found enum `\u001b[1m\u001b[35mstructure::data::content::Content<'_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\structure\\parser\\line.rs","byte_start":426,"byte_end":433,"line_start":16,"line_end":16,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        content,","highlight_start":9,"highlight_end":16}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\structure\\parser\\line.rs:16:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         content,\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n  \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m 6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n   \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m 7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n   \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n\n"}
{"$message_type":"diagnostic","message":"`Option<Box<dyn as_content::Content<'f>>>` doesn't implement `std::fmt::Display`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":212,"byte_end":224,"line_start":5,"line_end":5,"column_start":53,"column_end":65,"is_primary":true,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":53,"highlight_end":65}],"label":"`Option<Box<dyn as_content::Content<'f>>>` cannot be formatted with the default formatter","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":168,"byte_end":225,"line_start":5,"line_end":5,"column_start":9,"column_end":66,"is_primary":false,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":9,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"write!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21785,"byte_end":21803,"line_start":610,"line_end":610,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! write {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":34951,"byte_end":34975,"line_start":997,"line_end":997,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"desugaring of format string literal","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":181,"byte_end":183,"line_start":5,"line_end":5,"column_start":22,"column_end":24,"is_primary":false,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":22,"highlight_end":24}],"label":"required by this formatting parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":168,"byte_end":225,"line_start":5,"line_end":5,"column_start":9,"column_end":66,"is_primary":false,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":9,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"write!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21785,"byte_end":21803,"line_start":610,"line_end":610,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! write {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":34951,"byte_end":34975,"line_start":997,"line_end":997,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"desugaring of format string literal","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `std::fmt::Display` is not implemented for `Option<Box<dyn as_content::Content<'f>>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: `Option<Box<dyn as_content::Content<'f>>>` doesn't implement `std::fmt::Display`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\structure\\display\\line.rs:5:53\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)\n  \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m--\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`Option<Box<dyn as_content::Content<'f>>>` cannot be formatted with the default formatter\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96mrequired by this formatting parameter\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the trait `std::fmt::Display` is not implemented for `Option<Box<dyn as_content::Content<'f>>>`\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait `as_content::Content` is not dyn compatible","code":{"code":"E0038","explanation":"For any given trait `Trait` there may be a related _type_ called the _trait\nobject type_ which is typically written as `dyn Trait`. In earlier editions of\nRust, trait object types were written as plain `Trait` (just the name of the\ntrait, written in type positions) but this was a bit too confusing, so we now\nwrite `dyn Trait`.\n\nSome traits are not allowed to be used as trait object types. The traits that\nare allowed to be used as trait object types are called \"dyn-compatible\"[^1]\ntraits. Attempting to use a trait object type for a trait that is not\ndyn-compatible will trigger error E0038.\n\nTwo general aspects of trait object types give rise to the restrictions:\n\n  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n     these types can only be accessed through pointers, such as `&dyn Trait` or\n     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n     with it, and different trait objects with the same trait object type may\n     have different sizes.\n\n  2. The pointer used to access a trait object is paired with an extra pointer\n     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n     dispatch to the object's implementations of the trait's methods. There is a\n     single such vtable for each trait implementation, but different trait\n     objects with the same trait object type may point to vtables from different\n     implementations.\n\nThe specific conditions that violate dyn-compatibility follow, most of which\nrelate to missing size information and vtable polymorphism arising from these\naspects.\n\n[^1]: Formerly known as \"object-safe\".\n\n### The trait requires `Self: Sized`\n\nTraits that are declared as `Trait: Sized` or which otherwise inherit a\nconstraint of `Self:Sized` are not dyn-compatible.\n\nThe reasoning behind this is somewhat subtle. It derives from the fact that Rust\nrequires (and defines) that every trait object type `dyn Trait` automatically\nimplements `Trait`. Rust does this to simplify error reporting and ease\ninteroperation between static and dynamic polymorphism. For example, this code\nworks:\n\n```\ntrait Trait {\n}\n\nfn static_foo<T:Trait + ?Sized>(b: &T) {\n}\n\nfn dynamic_bar(a: &dyn Trait) {\n    static_foo(a)\n}\n```\n\nThis code works because `dyn Trait`, if it exists, always implements `Trait`.\n\nHowever as we know, any `dyn Trait` is also unsized, and so it can never\nimplement a sized trait like `Trait:Sized`. So, rather than allow an exception\nto the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\nsuch a `dyn Trait` from existing at all.\n\nOnly unsized traits are considered dyn-compatible.\n\nGenerally, `Self: Sized` is used to indicate that the trait should not be used\nas a trait object. If the trait comes from your own crate, consider removing\nthis restriction.\n\n### Method references the `Self` type in its parameters or return type\n\nThis happens when a trait has a method like the following:\n\n```\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nimpl Trait for String {\n    fn foo(&self) -> Self {\n        \"hi\".to_owned()\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) -> Self {\n        1\n    }\n}\n```\n\n(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\ncause this problem.)\n\nIn such a case, the compiler cannot predict the return type of `foo()` in a\nsituation like the following:\n\n```compile_fail,E0038\ntrait Trait {\n    fn foo(&self) -> Self;\n}\n\nfn call_foo(x: Box<dyn Trait>) {\n    let y = x.foo(); // What type is y?\n    // ...\n}\n```\n\nIf only some methods aren't dyn-compatible, you can add a `where Self: Sized`\nbound on them to mark them as explicitly unavailable to trait objects. The\nfunctionality will still be available to all other implementers, including\n`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\nTrait>`).\n\n```\ntrait Trait {\n    fn foo(&self) -> Self where Self: Sized;\n    // more functions\n}\n```\n\nNow, `foo()` can no longer be called on a trait object, but you will now be\nallowed to make a trait object, and that will be able to call any dyn-compatible\nmethods. With such a bound, one can still call `foo()` on types implementing\nthat trait that aren't behind trait objects.\n\n### Method has generic type parameters\n\nAs mentioned before, trait objects contain pointers to method tables. So, if we\nhave:\n\n```\ntrait Trait {\n    fn foo(&self);\n}\n\nimpl Trait for String {\n    fn foo(&self) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo(&self) {\n        // implementation 2\n    }\n}\n// ...\n```\n\nAt compile time each implementation of `Trait` will produce a table containing\nthe various methods (and other items) related to the implementation, which will\nbe used as the virtual method table for a `dyn Trait` object derived from that\nimplementation.\n\nThis works fine, but when the method gains generic parameters, we can have a\nproblem.\n\nUsually, generic parameters get _monomorphized_. For example, if I have\n\n```\nfn foo<T>(x: T) {\n    // ...\n}\n```\n\nThe machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\nother instantiation is different. Hence the compiler generates the\nimplementation on-demand. If you call `foo()` with a `bool` parameter, the\ncompiler will only generate code for `foo::<bool>()`. When we have additional\ntype parameters, the number of monomorphized implementations the compiler\ngenerates does not grow drastically, since the compiler will only generate an\nimplementation if the function is called with fully concrete arguments\n(i.e., arguments which do not contain any generic parameters).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T);\n    // more methods\n}\n\nimpl Trait for String {\n    fn foo<T>(&self, on: T) {\n        // implementation 1\n    }\n}\n\nimpl Trait for u8 {\n    fn foo<T>(&self, on: T) {\n        // implementation 2\n    }\n}\n\n// 8 more implementations\n```\n\nNow, if we have the following code:\n\n```compile_fail,E0038\n# trait Trait { fn foo<T>(&self, on: T); }\n# impl Trait for String { fn foo<T>(&self, on: T) {} }\n# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n# // etc.\nfn call_foo(thing: Box<dyn Trait>) {\n    thing.foo(true); // this could be any one of the 8 types above\n    thing.foo(1);\n    thing.foo(\"hello\");\n}\n```\n\nWe don't just need to create a table of all implementations of all methods of\n`Trait`, we need to create such a table, for each different type fed to\n`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\ntypes being fed to `foo()`) = 30 implementations!\n\nWith real world traits these numbers can grow drastically.\n\nTo fix this, it is suggested to use a `where Self: Sized` bound similar to the\nfix for the sub-error above if you do not intend to call the method with type\nparameters:\n\n```\ntrait Trait {\n    fn foo<T>(&self, on: T) where Self: Sized;\n    // more methods\n}\n```\n\nIf this is not an option, consider replacing the type parameter with another\ntrait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\nnumber of types you intend to feed to this method is limited, consider manually\nlisting out the methods of different types.\n\n### Method has no receiver\n\nMethods that do not take a `self` parameter can't be called since there won't be\na way to get a pointer to the method table for them.\n\n```\ntrait Foo {\n    fn foo() -> u8;\n}\n```\n\nThis could be called as `<Foo as Foo>::foo()`, which would not be able to pick\nan implementation.\n\nAdding a `Self: Sized` bound to these methods will generally make this compile.\n\n```\ntrait Foo {\n    fn foo() -> u8 where Self: Sized;\n}\n```\n\n### Trait contains associated constants\n\nJust like static functions, associated constants aren't stored on the method\ntable. If the trait or any subtrait contain an associated constant, they are not\ndyn compatible.\n\n```compile_fail,E0038\ntrait Foo {\n    const X: i32;\n}\n\nimpl dyn Foo {}\n```\n\nA simple workaround is to use a helper method instead:\n\n```\ntrait Foo {\n    fn x(&self) -> i32;\n}\n```\n\n### Trait uses `Self` as a type parameter in the supertrait listing\n\nThis is similar to the second sub-error, but subtler. It happens in situations\nlike the following:\n\n```compile_fail,E0038\ntrait Super<A: ?Sized> {}\n\ntrait Trait: Super<Self> {\n}\n\nstruct Foo;\n\nimpl Super<Foo> for Foo{}\n\nimpl Trait for Foo {}\n\nfn main() {\n    let x: Box<dyn Trait>;\n}\n```\n\nHere, the supertrait might have methods as follows:\n\n```\ntrait Super<A: ?Sized> {\n    fn get_a(&self) -> &A; // note that this is dyn-compatible!\n}\n```\n\nIf the trait `Trait` was deriving from something like `Super<String>` or\n`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n`get_a()` will definitely return an object of that type.\n\nHowever, if it derives from `Super<Self>`, even though `Super` is\ndyn-compatible, the method `get_a()` would return an object of unknown type when\ncalled on the function. `Self` type parameters let us make dyn-compatible traits\nno longer compatible, so they are forbidden when specifying supertraits.\n\nThere's no easy fix for this. Generally, code will need to be refactored so that\nyou no longer need to derive from `Super<Self>`.\n"},"level":"error","spans":[{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":181,"byte_end":183,"line_start":5,"line_end":5,"column_start":22,"column_end":24,"is_primary":true,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":22,"highlight_end":24}],"label":"`as_content::Content` is not dyn compatible","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21863,"byte_end":21893,"line_start":612,"line_end":612,"column_start":24,"column_end":54,"is_primary":false,"text":[{"text":"        $dst.write_fmt($crate::format_args!($($arg)*))","highlight_start":24,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\structure\\display\\line.rs","byte_start":168,"byte_end":225,"line_start":5,"line_end":5,"column_start":9,"column_end":66,"is_primary":false,"text":[{"text":"        write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)","highlight_start":9,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"write!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":21785,"byte_end":21803,"line_start":610,"line_end":610,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! write {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args!","def_site_span":{"file_name":"C:\\Users\\Admin\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\macros\\mod.rs","byte_start":34951,"byte_end":34975,"line_start":997,"line_end":997,"column_start":5,"column_end":29,"is_primary":false,"text":[{"text":"    macro_rules! format_args {","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"desugaring of format string literal","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for a trait to be dyn compatible it needs to allow building a vtable\nfor more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>","code":null,"level":"note","spans":[{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":63,"byte_end":70,"line_start":6,"line_end":6,"column_start":11,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Content<'lc> {","highlight_start":11,"highlight_end":18}],"label":"this trait is not dyn compatible...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":true,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":"...because method `check` references an `impl Trait` type in its return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"lore_ir\\src\\content_types\\as_content\\mod.rs","byte_start":102,"byte_end":119,"line_start":7,"line_end":7,"column_start":24,"column_end":41,"is_primary":false,"text":[{"text":"    fn check(&self) -> impl Content<'lc>;","highlight_start":24,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `impl Trait`","def_site_span":{"file_name":"lore_ir\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"consider moving `check` to another trait","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0038]\u001b[0m\u001b[1m\u001b[97m: the trait `as_content::Content` is not dyn compatible\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\structure\\display\\line.rs:5:22\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         write!(f, \"{}{}\", \"  \".repeat(self.indent), self.content)\n  \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91m`as_content::Content` is not dyn compatible\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: for a trait to be dyn compatible it needs to allow building a vtable\n      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>\n \u001b[1m\u001b[96m--> \u001b[0mlore_ir\\src\\content_types\\as_content\\mod.rs:7:24\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m6\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub trait Content<'lc> {\n  \u001b[1m\u001b[96m|\u001b[0m           \u001b[1m\u001b[96m-------\u001b[0m \u001b[1m\u001b[96mthis trait is not dyn compatible...\u001b[0m\n\u001b[1m\u001b[96m7\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     fn check(&self) -> impl Content<'lc>;\n  \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92m...because method `check` references an `impl Trait` type in its return type\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: consider moving `check` to another trait\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the macro `$crate::format_args` which comes from the expansion of the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 18 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 18 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0038, E0277, E0308, E0583, E0746.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0038, E0277, E0308, E0583, E0746.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0038`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0038`.\u001b[0m\n"}
